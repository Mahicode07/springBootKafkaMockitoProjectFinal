What is Maven and what problem does it solve?
Maven is a build automation tool used primarily for Java projects. It simplifies and standardizes the
build process, manages dependencies, and provides project structure conventions.

What is a POM file in Maven?
POM (Project Object Model) is an XML file that contains project information and configuration details
required by Maven for building the project. It includes dependencies, plugins, and other settings

What is the difference between compile and runtime dependencies in Maven?
Compile dependencies are required for compiling the code, while runtime dependencies are only
needed during execution. Maven manages these dependencies differently based on their scope.

maven lifecycle?
| Lifecycle   | Purpose                        |
| ----------- | ------------------------------ |
| **Clean**   | Clean old build output         |
| **Default** | Build, test, package, deploy   |
| **Site**    | Generate project documentation |
1Ô∏è‚É£ Clean Lifecycle
Used to clean previous build artifacts.
| Phase        | What it does                |
| ------------ | --------------------------- |
| `pre-clean`  | Prepare for cleaning        |
| `clean`      | Deletes `target/` directory |
| `post-clean` | After cleaning              |
2Ô∏è‚É£ Default Lifecycle
When you run any phase, Maven executes all previous phases automatically
1. validate
Checks if:
pom.xml is valid
Project structure is correct
üëâ Ensures build can start safely.
2. compile
Compiles main source code
src/main/java ‚Üí target/classes
üëâ No tests compiled yet.
3. test
Compiles test code
Runs unit tests (JUnit, TestNG)
src/test/java
‚ùå If any test fails ‚Üí build fails
4. package
Packages compiled code into:
jar
war,ear
Example:
target/myapp.jar
üëâ Used for deployment or sharing.
5. verify
Runs additional checks:
Integration tests
Code quality checks
üëâ Ensures package is valid.
6. install
Copies package into local Maven repository
~/.m2/repository
üëâ Makes it available for other local projects.
7. deploy
Uploads artifact to:
Nexus
Artifactory
Remote repository
üëâ Used in CI/CD pipelines.

What is a Maven Repository?
A Maven repository is a directory where all project jars, library jar, plugins, or any other projectspecific artifacts
are stored and can be easily used by Maven

How do you exclude dependencies in Maven?
You can exclude dependencies using the <exclusions> element within the <dependency> tag in the
POM file. This allows you to exclude specific transitive dependencies that you don't need

How can we optimize a Maven build for a large project?
To optimize a Maven build for a large project, use dependency management, configure Maven to skip
unnecessary tasks, use parallel builds, and leverage a local repository manager for faster artifact retrieval.

How do you run a Maven build?
To run a Maven build, open your command line, navigate to the directory containing your project's
pom.xml file, and type mvn package to build the project

What is the difference between mvn clean and mvn install?
The difference between mvn clean and mvn install is that mvn clean removes files generated
in the previous builds, cleaning the project, while mvn install compiles the project code and
installs the built package into the local repository, making it available for other projects.

maven vs gradle?
1. Build Tool Type
Maven ‚Üí Declarative build tool. You only describe the project structure and dependencies;
Maven decides how and when tasks run using a fixed lifecycle.
Gradle ‚Üí Declarative + programmatic build tool. You describe the project and can also write logic to control task execution.
Gradle Example:
tasks.register("hello") {
    doLast { println "Hello Gradle" }
}

2. Build Configuration File
Maven ‚Üí Uses pom.xml as the single configuration file.
<project>
  <groupId>com.example</groupId>
  <artifactId>demo</artifactId>
  <version>1.0</version>
</project>

Gradle ‚Üí Uses build.gradle or build.gradle.kts.
group = "com.example"
version = "1.0"

3. Configuration Language
Maven ‚Üí XML only, no scripting.
<dependencies>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>5.3.25</version>
  </dependency>
</dependencies>
Gradle ‚Üí Groovy/Kotlin with logic support.
dependencies {
    implementation("org.springframework:spring-core:5.3.25")
}

4. Readability
Maven ‚Üí Verbose and repetitive.
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
</plugin>
Gradle ‚Üí Short and clean.
java

5. Learning Curve
Maven ‚Üí Easy due to conventions.
Gradle ‚Üí Moderate because of scripting.
(No code snippet needed)

6. Build Performance
Maven ‚Üí Slower, rebuilds everything.
mvn clean install
Gradle ‚Üí Faster, only builds changed tasks.
gradle build

7. Incremental Build Support
Maven ‚Üí Limited incremental support.
Gradle ‚Üí Strong incremental build and caching.

tasks.withType(JavaCompile) {
    options.incremental = true
}

8. Plugin Usage
Maven ‚Üí XML-based plugin configuration.
<plugin>
  <artifactId>maven-surefire-plugin</artifactId>
</plugin>
Gradle ‚Üí Code-based plugin application.
plugins {
    id 'java'
}

9. Custom Build Logic
Maven ‚Üí Hard to add custom tasks.
Gradle ‚Üí Easy to define custom tasks.
task cleanTemp {
    doLast { delete "temp" }
}

10. Configuration Flexibility
Maven ‚Üí Strict convention, limited flexibility.
Gradle ‚Üí Highly configurable.
if (project.hasProperty("env")) {
    println "Environment: $env"
}

11. Multi-Module Project Support
Maven ‚Üí Parent POM + module definitions.
<modules>
  <module>service-a</module>
  <module>service-b</module>
</modules>
Gradle ‚Üí settings.gradle for modules.
include("service-a", "service-b")

12. CI/CD Usage
Maven ‚Üí Stable, widely used.
mvn deploy
Gradle ‚Üí Faster, cache-friendly.
gradle build --build-cache
========================================================================================================================
If you needed to switch an existing project from Maven to Gradle, what challenges might you
face during the migration, and how would you address them?
Switching from Maven to Gradle can present challenges such as converting Maven's XML
configurations to Gradle's Groovy or Kotlin DSL scripts. The key is understanding both build syntaxes
and translating dependencies, plugins, and custom build tasks accordingly. Start by using the gradle
init command, which helps to convert a Maven project to Gradle automatically. Then, manually
adjust and optimize the build scripts to leverage Gradle's features and performance advantages,
ensuring all project specifications are met effectively.
========================================================================================================================
 How do you handle library dependencies in a Gradle project?
In a Gradle project, you manage library dependencies by specifying them in the build.gradle file. You
add dependencies within the dependencies block, categorizing them as implementation,
testImplementation, etc., based on their usage context. List each dependency with its group ID,
artifact ID, and version number. Gradle automatically resolves and downloads these from specified
repositories, typically jCenter or Maven Central, ensuring your project has all necessary libraries for
building and testing. This streamlined approach helps manage dependencies efficiently and keeps
the project setup clear
========================================================================================================================
Scenario: You need to configure a multi-project build with Gradle. What considerations would
you take into account?
When configuring a multi-project build with Gradle, consider structuring the directory layout to
reflect each subproject's role and dependencies. In your root project's build.gradle, define common
configurations and dependencies that apply across subprojects to avoid duplication. Use the
settings.gradle file to include all the subprojects. This setup allows for shared behavior while
managing specific dependencies or tasks at the subproject level, optimizing build processes and
resource management across the entire project structure.
========================================================================================================================
How can you implement a custom task in Gradle, and what are some use cases for it?
To implement a custom task in Gradle, define a task in the build.gradle file using Groovy or Kotlin
syntax, specifying the task's action within a closure or a lambda expression. Common use cases for
custom tasks include automating repetitive processes like file management (copying, renaming),
performing health checks, or generating reports. For example, you might create a task to automate
the setup of environment configurations or to preprocess resources before the main build executes.
This customization enhances the build process's efficiency and adaptability to specific project needs
========================================================================================================================
How do you manage environment-specific configurations in a Gradle project?
In a Gradle project, manage environment-specific configurations by creating separate Gradle files for
each environment (like dev.gradle, prod.gradle) or by defining environment-specific blocks within the
build.gradle file. Use Gradle's project properties to switch between these configurations at build
time, typically through command-line options (-Penv=prod). This approach allows you to tailor
settings, dependencies, and tasks to each environment, ensuring that the build process is correctly
configured for development, testing, or production as needed.
========================================================================================================================
Explain how to use Gradle's build cache feature and its benefits.
Gradle's build cache feature stores the outputs of previously executed tasks and reuses them for
future builds if the inputs haven't changed. To use it, enable the build cache in your gradle.properties
file by setting org.gradle.caching=true. This optimization reduces build time significantly, especially in
large projects or in continuous integration environments. It avoids redundant computations,
speeding up both local and CI/CD builds by reusing artifacts from earlier runs, enhancing overall efficiency
========================================================================================================================
Scenario: How would you configure a Gradle project to publish artifacts to a remote repository?
To configure a Gradle project to publish artifacts to a remote repository, first add the maven-publish
plugin to your build.gradle file. Define the publication details in the publishing block, specifying the
group ID, artifact ID, and version of your artifact. Set up the repository URL and credentials in the
repositories block. Finally, use the gradle publish command to upload your artifacts. This setup
automates the distribution of builds, making them accessible for deployment or sharing.
========================================================================================================================
Scenario: You have multiple modules in a Gradle project, and you want to ensure they all use
the same version of a dependency. How would you manage this?
To ensure all modules in a Gradle project use the same version of a dependency, utilize a root
build.gradle file to define common dependencies. In the subprojects block of this root file, specify
the dependency version that all modules should use. For example, subprojects { dependencies {
implementation 'com.example:library:1.2.3' } }. This centralized approach guarantees that every
module inherits and applies the same dependency version, promoting consistency across the project.
========================================================================================================================
bitbucket vs gitlab?

Architecture & Design Philosophy
GitLab: Monolithic application architecture, single codebase for all features, follows "convention over configuration"
Bitbucket: Microservices-oriented architecture, integrates with Atlassian ecosystem as separate services

CI/CD Capabilities
GitLab CI/CD: YAML-based pipelines, native auto-scaling runners, extensive caching mechanisms, supports DAG pipelines, built-in artifact management
Bitbucket Pipelines: YAML-based, Docker-based execution, limited parallelization on free tier, simpler configuration but less flexible

Merge/Pull Request Features
GitLab: Merge requests with approval rules, merge trains, draft MRs, suggestion commits, threaded discussions
Bitbucket: Pull requests with code insights, default reviewers, automatic merging, task lists in PRs

Access Control & Permissions
GitLab: Project-level, group-level, and instance-level permissions with granular role-based access control (Owner, Maintainer, Developer, Reporter, Guest)
Bitbucket: Repository, project, and workspace permissions integrated with Jira permissions when applicable

Code Review Tools
GitLab: Inline comments, suggestion feature for direct code changes, review apps for testing MRs
Bitbucket: Inline comments, tasks in PRs, integration with Crucible for formal reviews

Deployment & Release Management
GitLab: Built-in deployment boards, environments tracking, feature flags, release management, automated rollbacks
Bitbucket: Deployments via Pipelines, requires external tools for advanced release management

Security Features
GitLab: SAST, DAST, dependency scanning, container scanning, license compliance all built-in
Bitbucket: Basic security through integrations, requires third-party tools for comprehensive scanning

Repository Mirroring
GitLab: Push and pull repository mirroring, supports scheduled syncs
Bitbucket: Limited mirroring capabilities, primarily through Smart Mirroring in Data Center

API & Extensibility
GitLab: Comprehensive REST API, GraphQL API, extensive webhook support, custom project templates
Bitbucket: REST API, webhook support, Atlassian Connect for app development

Container Registry
GitLab: Built-in container registry with vulnerability scanning
Bitbucket: No native container registry, requires external solutions like Docker Hub or AWS ECR

Issue Tracking
GitLab: Full-featured issue tracking with boards, milestones, epics, time tracking, weights
Bitbucket: Basic issue tracking, typically defers to Jira for comprehensive project management

Wiki & Documentation
GitLab: Built-in wiki per project, pages for static site hosting
Bitbucket: Limited wiki functionality, typically uses Confluence for documentation

Performance & Scalability
GitLab: Can be resource-intensive, requires significant infrastructure for large deployments, supports horizontal scaling
Bitbucket: Generally lighter weight, scales well with Atlassian Data Center architecture

Pricing Model
GitLab: Free tier with 400 CI/CD minutes, paid tiers based on users, self-hosted Community Edition is free
Bitbucket: Free for small teams (up to 5 users), pricing based on users, Data Center for enterprise self-hosting

Community & Open Source
GitLab: Fully open-source core (Community Edition), transparent development, active community contributions
Bitbucket: Proprietary software, less community-driven development

Branch Protection & Policies
GitLab: Protected branches with push/merge rules, code owner approvals, required pipelines
Bitbucket: Branch permissions, merge checks, required approvals, build status requirements

Audit & Compliance
GitLab: Comprehensive audit events, compliance frameworks, audit reports
Bitbucket: Audit logging in Data Center, integration with Jira for compliance tracking

Code Search
GitLab: Advanced code search with Elasticsearch integration, supports regex
Bitbucket: Basic code search, enhanced search in Data Center version
========================================================================================================================


