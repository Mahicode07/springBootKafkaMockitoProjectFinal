Hibernate ORM framework for mapping Java objects to relational database tables seamlessly.
It is a high-level API that manages the data persistence layer in Java applications.
allowing developers to work with objects in Java and have them automatically persisted to and
retrieved from a relational database.
Hibernate features->
Database Independence->Hibernate provides a level of abstraction over JDBC (Java Database Connectivity)
and SQL, enabling developers to switch between different database vendors without changing the code.
Simplified Data Persistence->With Hibernate, developers don’t need to write complex SQL queries for CRUD (Create, Read, Update, Delete) operations.
Automatic Mapping->Hibernate maps Java objects to database tables automatically using annotations or XML configuration,
so developers don’t need to manually write mappings.
Support for Transactions: Hibernate integrates seamlessly with Java transaction management APIs (like JTA and Spring),
allowing you to handle complex transaction scenarios.
===========================================================================================================================================
What is ORM (Object Relational Mapping)?
 is a programming technique that allows developers to map objects in an object-oriented language like Java to relational database tables.
=============================================================================================================================================
What are the advantages of using Hibernate over JDBC?
Simplified Database Interaction: In JDBC, developers have to manually write SQL queries for CRUD operations,
which can lead to a lot of boilerplate code. Hibernate abstracts this process, and most queries are auto-generated,
reducing the need for repetitive SQL code.
Object-Oriented Approach: Hibernate uses Java objects to represent data, making it more natural to work with databases
in an object-oriented programming language. JDBC, on the other hand, works with SQL and result sets,
which can make it harder to map data into Java objects.
Automatic Mapping: Hibernate automatically maps Java classes to database tables using annotations or XML configuration,
saving developers time and effort. JDBC requires developers to handle object-relational mapping manually, which can be tedious and error-prone.
Transaction Management: Hibernate provides built-in transaction management and integrates well with Java transaction management frameworks like JTA and Spring.
JDBC requires manual handling of transactions, which increases complexity and the chance of errors.
Database Independence-> Switching databases in Hibernate is straightforward and requires minimal changes to the code. In JDBC,
you typically need to rewrite SQL queries for each database, leading to more maintenance overhead.
Caching Mechanisms: Hibernate has a built-in caching system (first-level and second-level caches) to improve performance, reducing the number of database hits.
JDBC doesn’t provide caching capabilities, leading to potentially inefficient database access.
Lazy Loading and Eager Loading: Hibernate supports lazy loading and eager loading strategies to manage how data is retrieved from the database,
which improves performance by fetching only the data you need. JDBC lacks this level of flexibility.
============================================================================================================================================
What are the main components of Hibernate?
Configuration: The configuration component in Hibernate is responsible for reading the hibernate.cfg.xml or hibernate.properties file,
which contains database connection details and configuration settings for Hibernate. It sets up the environment, including the SessionFactory.
SessionFactory: The SessionFactory is a thread-safe object responsible for creating Session objects. It holds configuration information and is used to initialize the database connection.
It also serves as the factory for all sessions in the application.
Session: The Session is the primary interface for interacting with the database. It represents a single unit of work and allows operations like saving,
updating, deleting, and querying objects. The session is responsible for managing the persistence state of Java objects.
Transaction: The Transaction component is responsible for managing database transactions. It ensures that database operations are carried out atomically,
meaning that either all changes are committed, or none are, in case of errors.
Query: The Query object allows developers to execute HQL (Hibernate Query Language) queries or SQL queries against the database.
It supports both HQL (Hibernate's own query language) and native SQL queries.
Criteria: The Criteria API provides an object-oriented way to create queries dynamically. It's more flexible and safe from SQL injection compared to HQL
Interceptor: Interceptors allow for event-based handling, such as when an object is saved, updated, or deleted.
Custom logic can be injected into the Hibernate lifecycle events through interceptors.
============================================================================================================================================
What is a Hibernate configuration file?
XML file that contains all the necessary configuration details for setting up a Hibernate application.
hibernate.dialect: Specifies the SQL dialect for the underlying database (e.g., org.hibernate.dialect.MySQLDialect for MySQL).
hibernate.hbm2ddl.auto: Defines how Hibernate should handle schema generation (e.g., update, create, validate).
hibernate.connection.url: The JDBC URL to connect to the database.
hibernate.connection.username: The username used for connecting to the database.
hibernate.connection.password: The password used for connecting to the database.
hibernate.show_sql: A boolean flag to enable or disable the logging of SQL statements generated by Hibernate
============================================================================================================================================
What is the role of SessionFactory in Hibernate?
The SessionFactory in Hibernate is a thread-safe factory responsible for creating Session objects.
It holds the configuration for Hibernate and is responsible for managing the database connection pool.
. It also caches metadata and manages the configuration settings used by Hibernate.
Once the SessionFactory is created, it is shared across the application, and it creates Session objects for interacting with the database.
Each Session is associated with a single unit of work (like an HTTP request) and can perform CRUD operations.
The SessionFactory is an expensive object to create, so it's typically initialized once and used throughout the application's lifecycle
============================================================================================================================================
 What is the purpose of the Session interface in Hibernate?
 The Session interface in Hibernate represents a single unit of work. It is the main interface for interacting with the database in Hibernate
 Save, update, or delete Java objects to and from the database.
 Retrieve entities using HQL (Hibernate Query Language) or Criteria.
 Start and manage transactions.
 Perform session-level operations like flush, clear, and evict.
 he Session is not thread-safe, so it is generally created, used, and closed per unit of work, such as per request in a web application.
 ============================================================================================================================================
 What are the different states of a Hibernate object?
 Transient: An object is in the transient state when it is created but not yet saved to the database.
 It is not associated with a Hibernate session and is not tracked by the Hibernate context.
 Persistent: An object becomes persistent when it is associated with a Hibernate session. Changes made to the persistent object are automatically
 synchronized with the database when the session is flushed or the transaction is committed.
 Detached: A persistent object becomes detached when the Session that was managing it is closed or the object is explicitly detached.
  It is no longer managed by the Hibernate session but still exists and can be reattached to a session later.
  Removed: An object enters the removed state when it is marked for deletion (e.g., through a session.delete() call).
  It is not deleted from the database until the transaction is committed and the session is flushed.
============================================================================================================================================
Explain the difference between load() and get() methods in Hibernate.
Both the load() and get() methods are used to retrieve an entity by its primary key, but there are important differences:
get():
It always hits the database and retrieves the entity by its primary key. If the entity does not exist, it returns null.
It does not throw an exception if the entity is not found.
It is useful when you expect the entity to exist and want to handle the null case explicitly.
load():
It does not immediately hit the database. It returns a proxy object that will be loaded lazily when any method is called on it.
If the entity does not exist, load() throws a ObjectNotFoundException.
It is typically used when you want to take advantage of lazy loading and expect the entity to exist.
============================================================================================================================================
What are the basic annotations used in Hibernate?
Entity,Id,@GeneratedValue: Specifies the strategy for generating the primary key value
Table,column,@ManyToOne, @OneToMany, @OneToOne, @ManyToMany:
@JoinColumn: Specifies the column that will be used to join two related entities, often used in associations like @ManyToOne.
@JoinTable: Used in many-to-many relationships to define a join table and specify its columns.
@Embeddable and @Embedded: These annotations allow an embedded object to be part of an entity, representing complex attributes that are not their own entity.
@Version: Used to implement optimistic locking by marking a version column in the entity for concurrency control.
============================================================================================================================================
 What is the role of @GeneratedValue in Hibernate?
 The @GeneratedValue annotation is used in conjunction with the @Id annotation to define how the primary key of an entity is generated
 GenerationType.AUTO: Let Hibernate choose the appropriate strategy based on the database.
 GenerationType.IDENTITY: Use an auto-incrementing column for primary key generation.
 GenerationType.SEQUENCE: Use a database sequence to generate primary keys (usually for databases like PostgreSQL, Oracle).
 GenerationType.TABLE: Use a special table to generate primary key values (less common).
 ============================================================================================================================================
 What are the types of inheritance mapping in Hibernate?
 Hibernate supports three types of inheritance mapping strategies to map the inheritance relationship in Java to a relational database:
 Single Table Inheritance: All classes in the inheritance hierarchy are mapped to a single database table.
 A discriminator column is used to differentiate between different types in the hierarchy.
 Pros: It’s efficient because there’s only one table.
 Cons: The table may have many columns, including null values for fields that don't apply to certain subclasses
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "type")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
}

@Entity
@DiscriminatorValue("MANAGER")
public class Manager extends Employee {
    private String department;
}

Joined Table Inheritance: Each class in the inheritance hierarchy is mapped to its own table.
The subclass tables reference the superclass table via foreign keys.
Pros: More normalized, avoids having many null columns.
Cons: Requires multiple joins to retrieve data, which may reduce performance.

Table Per Class Inheritance: Each class in the inheritance hierarchy is mapped to a separate table,
and no joins are required for querying. Each table includes all the fields of its class.
Pros: Simple and efficient for querying, especially when subclasses are not often used.
Cons: May lead to data redundancy because each table contains its own copy of common fields.
============================================================================================================================================
How do you map a one-to-many relationship in Hibernate?
A one-to-many relationship is a scenario where one entity is related to multiple instances of another entity.
In Hibernate, this is typically mapped using the @OneToMany annotation on the "one" side and @ManyToOne on the "many" side.
Steps to map a one-to-many relationship:
Use @OneToMany on the entity that has the "one" side of the relationship.
Use @ManyToOne on the entity that has the "many" side of the relationship.
Define the mapping on the "many" side with @JoinColumn to specify the foreign key.

@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}

@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
    }
In this example, a Department can have multiple Employees, and each Employee belongs to one Department.
============================================================================================================================================
What is the Criteria API in Hibernate?
The Criteria API in Hibernate is a powerful feature that allows you to build queries dynamically in an object-oriented manner, without writing HQL or SQL.
It is particularly useful for creating complex queries or queries that are constructed at runtime based on various conditions.
It allows the construction of queries programmatically, without directly writing HQL.
It is type-safe and provides support for operations like filtering (Restrictions), grouping, ordering, and pagination.
Session session = sessionFactory.openSession();
Criteria criteria = session.createCriteria(Employee.class);
criteria.add(Restrictions.gt("salary", 50000));  // Filter salary greater than 50000
List<Employee> employees = criteria.list();
session.close();
============================================================================================================================================
What is the difference between HQL and SQL in Hibernate?
Hibernate Query Language (HQL) is an object-oriented query language similar to SQL but operates on Java objects (entities) rather than database tables.
Object-Oriented vs. Relational:
HQL works with persistent objects (entities) and their properties, not directly with database tables or columns.
SQL is directly concerned with the database schema (tables, columns, joins, etc.).
Database Independence:
HQL abstracts the underlying database, meaning you can write a query in HQL and Hibernate will generate the appropriate SQL for the specific database being used.
SQL is database-specific, meaning queries need to be written in a way that matches the SQL dialect of the specific database.
Use of Aliases:
HQL allows you to work with object aliases. For example, when querying, you can refer to the entity and its properties.
SQL requires you to use table and column names.
============================================================================================================================================
What are the different types of caching mechanisms in Hibernate?
First-Level Cache (Session Cache)
It is a mandatory cache and exists for the duration of a Hibernate session.
The first-level cache is associated with a session, meaning it stores entities and their state for the lifetime of that session.
It is not shared across sessions, and when a session is closed, the cache is cleared.
Second-Level Cache (SessionFactory Cache)->
The second-level cache is optional and is shared across multiple sessions. It caches entities, collections, and queries at the session factory level
The second-level cache can be configured to use different caching providers, such as EHCache, Infinispan, or OSCache.
Query Cache:
The query cache is a cache for storing the results of queries, which is particularly useful when running the same query repeatedly with different parameters.
It is not enabled by default and needs to be explicitly configured alongside the second-level cache.
Shared Cache (Hibernate Cache):
The shared cache allows for caching at the transaction level, beyond just individual sessions or query results.
============================================================================================================================================
What is the purpose of the flush() method in Hibernate?
The flush() method in Hibernate is used to synchronize the state of the in-memory session with the database.
When you make changes to persistent objects (like saving, updating, or deleting), these changes are initially stored in the session's first-level cache.
The flush() method forces Hibernate to execute the necessary SQL statements to apply these changes to the database.
It ensures that all pending changes in the session are written to the database, making the database state consistent with the in-memory state of the session.
It is typically called automatically before a transaction is committed, but it can also be called explicitly when needed.

Flush does not commit a transaction. It only synchronizes the session’s state with the database.
Hibernate flushes automatically when a transaction is committed.
It can be invoked manually if you need to force synchronization before committing.
============================================================================================================================================
What is lazy loading and eager loading in Hibernate?
Lazy Loading:
In lazy loading, associated entities are loaded on demand. They are not fetched from the database until they are explicitly accessed.
This strategy can improve performance by deferring unnecessary database calls, but it can lead to the N+1 select problem if not handled carefully.
Eager Loading:
In eager loading, associated entities are loaded immediately with the parent entity.
The data for the associated entities is retrieved in the same query as the parent.
@ManyToOne(fetch = FetchType.EAGER)
=============================================================================================================================================
What is the @ManyToOne annotation used for?
The @ManyToOne annotation is used to define a many-to-one relationship between two entities in Hibernate.
This is used when multiple instances of one entity are associated with a single instance of another entity.
It is typically used on the "many" side of a relationship.
The @ManyToOne annotation is usually paired with @JoinColumn to specify the foreign key column
============================================================================================================================================
How do you handle transactions in Hibernate?
Transactions in Hibernate are managed through the Transaction interface. Hibernate supports both programmatic and declarative transaction management.
Typically, programmatic management is done using the beginTransaction(), commit(), and rollback() methods.
Transactions in Hibernate are managed using the Session object
A transaction is started using session.beginTransaction().
Changes are committed to the database using transaction.commit().
If there is an error, you can rollback the transaction using transaction.rollback().
============================================================================================================================================
What is the difference between Session and SessionFactory?
Session:
The Session is a single-threaded, short-lived object that represents a conversation between the application and the database.
It is used to create, read, and delete persistent objects, and is responsible for the persistence context (i.e., managing the state of entities).
It acts as an interface for interacting with the database and for managing transactions.
Every operation (e.g., saving an entity) is done in the context of a session, and it must be closed after use.
SessionFactory:
The SessionFactory is a thread-safe, heavyweight object that is responsible for creating Session instances.
It is typically created once during the application’s startup and is used throughout the application to get new sessions.
The SessionFactory holds the configuration for Hibernate and manages the connection pool and other related resources.
============================================================================================================================================
How do you handle database connections in Hibernate?
In Hibernate, database connections are managed using connection pooling mechanisms. The SessionFactory creates and manages a pool of database
connections that are used to perform operations on the database.
Connection Pooling: Hibernate can use third-party connection pooling libraries like C3P0, HikariCP, or DBCP to efficiently manage database connections.
property name="hibernate.c3p0.min_size">5</property>
<property name="hibernate.c3p0.max_size">20</property>
=============================================================================================================================================
What is a first-level cache in Hibernate?
The first-level cache in Hibernate is the session cache and is enabled by default for each session.
It is a cache that stores entities and their state during the lifecycle of the Session.
Once an entity is retrieved or persisted, it is stored in the first-level cache,
and subsequent requests for the same entity within the session will retrieve it from this cache, rather than querying the database again.
No configuration required: It is automatically handled by Hibernate.
============================================================================================================================================
What is the purpose of the @JoinColumn annotation?
The @JoinColumn annotation is used in Hibernate (and JPA) to specify the column that is used to join two entities in a relationship
(usually for one-to-many, many-to-one, and many-to-many mappings).
It defines the foreign key column in the database that refers to the associated entity.
============================================================================================================================================
How do you map a many-to-many relationship in Hibernate?
In Hibernate, a many-to-many relationship is mapped using two @ManyToMany annotations on both sides of the relationship.
A join table is typically used to map the relationship, which stores the foreign keys of both entities involved in the relationship.
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany
    @JoinTable(
      name = "student_course",
      joinColumns = @JoinColumn(name = "student_id"),
      inverseJoinColumns = @JoinColumn(name = "course_id"))
    private Set<Course> courses;
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students;
}
============================================================================================================================================
What is a second-level cache in Hibernate?
The second-level cache is an optional cache in Hibernate that is shared across multiple sessions
the second-level cache persists across session boundaries and can be used to store frequently accessed entities or collections.
Configurable: The second-level cache is configurable, and Hibernate supports several third-party caching providers, such as EHCache, Infinispan, and OSCache.
Improves performance: By caching frequently accessed data, it reduces database load and improves performance for read-heavy applications.
<property name="hibernate.cache.use_second_level_cache">true</property>
<property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
<property name="hibernate.cache.use_query_cache">true</property>
============================================================================================================================================
What is the difference between save() and persist() methods in Hibernate?
save():
The save() method is part of the Session API and returns the identifier of the entity (the primary key).
It does not guarantee that the entity is immediately persisted;
it merely places it in the persistence context and the actual database operation may happen later, during flush or commit.
save() can be used for both new and detached entities.

persist():
The persist() method is part of the JPA EntityManager API (but also available in Hibernate for JPA-based applications).
It does not return a value (i.e., no identifier).
It does not immediately make the entity persistent in the database; like save(), it relies on the session's flush mechanism.
persist() can only be used for new entities, and calling it on an existing entity will throw an exception.
============================================================================================================================================
What is the role of HibernateUtil class?
The HibernateUtil class is a utility class that is typically used to configure and initialize the Hibernate SessionFactory.
It provides a central point to manage the Hibernate configuration,
and it usually contains methods to retrieve the SessionFactory and to clean up resources.
Key responsibilities:
SessionFactory creation: It creates the SessionFactory based on the Hibernate configuration.
Session management: It provides access to the current Session for interacting with the database.
Shutdown: It shuts down the SessionFactory when the application terminates.
============================================================================================================================================
 What is a Detached object in Hibernate?
 A detached object in Hibernate is an object that was once persistent but is no longer associated with a Session
 A detached object is an entity that has been saved to the database and then the Session has been closed or the object has been evicted.
 Detached objects are not synchronized with the session's persistence context.
 You can reattach a detached object to a new session using methods like update(), merge(), or saveOrUpdate().
 ============================================================================================================================================
  How do you perform batch processing in Hibernate?
  To enable batch processing in Hibernate:
  Set the appropriate batch size in the configuration file.
  Use Session.save() or Session.update() in a loop, and periodically flush and clear the session to prevent memory issues.
  <property name="hibernate.jdbc.batch_size">50</property>
  <property name="hibernate.order_inserts">true</property>
  <property name="hibernate.order_updates">true</property>
  <property name="hibernate.batch_versioned_data">true</property
  ============================================================================================================================================
  How can you optimize the performance of a Hibernate-based application?
  Use Lazy Loading:
  Use lazy loading (FetchType.LAZY) to defer fetching related entities until they are actually accessed, reducing unnecessary database queries.
  Optimize Queries:
  Use HQL (Hibernate Query Language) or Criteria API to create efficient queries.
  Avoid N+1 select issues by using join fetch in HQL or Criteria queries to fetch related entities in a single query.
  Enable Caching:
  Enable second-level cache and query cache to reduce the number of database queries, especially for frequently accessed data.
  Batch Processing:
  For large amounts of data, use batch processing to reduce the number of database round-trips.
  Optimize Database Access:
  Minimize unnecessary database operations (e.g., redundant flush() or clear() calls). Use the session.flush() method only when necessary
  Use Projection or DTO Pattern:
  Instead of loading entire entities, use projections or Data Transfer Object (DTO) pattern to fetch only the required fields.
  Proper Indexing:
  Ensure your database tables have proper indexes to speed up lookups, particularly for frequently queried columns.
  Use Connection Pooling:
  Use a connection pooling mechanism (e.g., C3P0, HikariCP) to efficiently manage database connections.
  =============================================================================================================================================
  What is the difference between session.save() and session.saveOrUpdate()?
  save():
  The save() method is used to persist a new object to the database. It returns the identifier (ID) of the saved entity.
  If the entity is already persistent (i.e., it already exists in the session or database), it will throw an exception (org.hibernate.PersistentObjectException).
  saveOrUpdate():
  The saveOrUpdate() method is more flexible. It either saves a new entity or updates an existing one if the entity already exists (based on the ID).
  If the entity is already in the database, Hibernate performs an update. If the entity is not in the database, Hibernate performs an insert.
  ============================================================================================================================================
  What is cascading in Hibernate and what are the different types of cascading?
  Cascading in Hibernate refers to the propagation of certain operations (like persist, delete, update) from a parent entity to its associated entities.
  This is useful when you want the same operation to be performed on related entities automatically.
  CascadeType.PERSIST:
  Propagates the persist operation to the associated entities (i.e., saves related entities when the parent entity is saved).
  CascadeType.MERGE:
  Propagates the merge operation (updating entities) to associated entities.
  CascadeType.REFRESH:
  Propagates the refresh operation (reloading entities from the database) to associated entities
  CascadeType.REMOVE:
  Propagates the remove operation (deleting entities) to associated entities
  CascadeType.ALL:
  Propagates all operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH) to the associated entities.
  CascadeType.DETACH:
    Propagates the detach operation to associated entities (i.e., detaches related entities when the parent entity is detached).
  ============================================================================================================================================
  How do you handle concurrency in Hibernate?
  Concurrency in Hibernate can be managed in various ways to avoid issues like dirty reads, lost updates, or phantom reads
  Optimistic Locking:
  With optimistic locking, a version number or timestamp is used to track changes to an entity.
  When an update occurs, Hibernate checks if the version number or timestamp has changed since the entity was fetched.
  If it has, a StaleObjectStateException is thrown.
  To use optimistic locking:
  Add a @Version annotation to a field in your entity.
  Pessimistic Locking:
  With pessimistic locking, a lock is acquired on the database row during the transaction, preventing other transactions from modifying
  it until the current transaction is completed.
  This can be done using the LockMode in Hibernate queries.
  Employee emp = session.get(Employee.class, 1, LockMode.PESSIMISTIC_WRITE);
  ============================================================================================================================================
  What is the @OneToMany annotation and how is it used in Hibernate?
  The @OneToMany annotation in Hibernate is used to map a one-to-many relationship between two entities.
  It indicates that one entity is associated with multiple instances of another entity.
  Typically, the @OneToMany annotation is used on the "one" side of the relationship,
  and it is usually paired with the @ManyToOne annotation on the other side.
  ============================================================================================================================================
  How do you configure Hibernate for a specific database dialect?
  You can configure the dialect in the hibernate.cfg.xml file:
  <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
  ============================================================================================================================================
  How does Hibernate implement the factory pattern for SessionFactory?
  Hibernate implements the Factory design pattern for the SessionFactory to create Session objects.
  The SessionFactory is a thread-safe, heavyweight object that holds Hibernate configuration settings and connection pooling information.
  It is responsible for creating Session instances, which are used for interacting with the database.
  Hibernate provides a SessionFactoryBuilder to configure and build the SessionFactory.
============================================================================================================================================
 What is the difference between flush() and clear() in Hibernate?
 flush():
 The flush() method synchronizes the in-memory changes in the current session with the database.
 It forces Hibernate to execute any SQL statements that are pending in the session’s cache.
 However, flush() does not commit the transaction; it just writes the changes to the database.
 clear():
 The clear() method clears the first-level cache of the session.
 It removes all objects from the session’s cache and effectively detaches them, meaning Hibernate will not track any changes to these objects after the call.
 ============================================================================================================================================
  What is the role of Session.merge() method in Hibernate?
  The merge() method in Hibernate is used to either update an existing persistent entity or
  insert it if it does not already exist in the database, and it also returns the merged entity
  It is particularly useful in situations where an entity is detached (i.e., it was previously persistent but the session was closed or the entity was evicted).
  f the entity passed to merge() is detached (i.e., its session is closed or it was evicted), merge() reattaches it to the current session.
  It avoids PersistentObjectException, unlike update(), which throws an exception if the entity is detached.
  ============================================================================================================================================
   Explain the concept of dirty checking in Hibernate.
   Dirty checking is a mechanism in Hibernate that automatically tracks changes made to persistent objects (entities) in the session's persistence context.
   When an object is modified, Hibernate keeps track of its state and compares the current state with the state when the entity was initially loaded.
   If any changes are detected, Hibernate will automatically synchronize these changes to the database during the flush operation.
   Automatic Persistence: Dirty checking is triggered when the session is flushed, or when the transaction is committed.
   ============================================================================================================================================
    How can you handle the N+1 query problem in Hibernate?
    The N+1 query problem occurs when an application executes one query to retrieve a list of entities (N) and
    then executes additional queries (1 for each entity) to fetch related entities.
    Use Fetch Joins: Use HQL or Criteria API to fetch related entities in a single query using join fetch.
    Use Batch Fetching: Configure batch fetching in Hibernate to load collections or related entities in batches
    instead of one at a time.
    <property name="hibernate.default_batch_fetch_size">10</property>
    Use Entity Graphs: In JPA, you can use entity graphs to specify which related entities should be fetched eagerly.
    ============================================================================================================================================
What is a Hibernate proxy and how does it work?
A Hibernate proxy is a dynamic subclass that Hibernate creates for an entity. It allows lazy loading of associations by delaying the actual database
query until the proxy object is accessed. The proxy class behaves like the original
entity but intercepts the method calls to load the entity's data from the database.
================================================================================================================================================
How does Hibernate handle object identity and equality?
Hibernate handles object identity and equality by using the entity’s identifier (ID) to determine if two instances represent the same entity.
Identity: Hibernate ensures that an entity's identifier (usually the primary key) is unique within a session.
The same entity instance will be loaded only once per session.
Equality: Hibernate uses the equals() and hashCode() methods to determine equality between entity instances.
=================================================================================================================================================
How can you map an enum type in Hibernate?
In Hibernate, enum types can be mapped to database columns in two main ways:

Ordinal Mapping: Store the ordinal (integer index) of the enum constant.
String Mapping: Store the name of the enum constant as a string.
public enum Status {
    ACTIVE, INACTIVE, PENDING
}

@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private Status status;

    // getters and setters
}
============================================================================================================================================
What is the difference between @Embedded and @Embeddable in Hibernate?
The @Embedded and @Embeddable annotations are used in Hibernate to handle composite types (complex types that consist of multiple fields) but
are used in different contexts:
@Embeddable:
This annotation is applied to a class, marking it as a composite type that can be embedded within other entities.
It represents a value type that is meant to be part of another entity.
The fields of this class are not mapped to a separate table but are stored as part of the parent entity's table.
@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
}

@Embedded:
This annotation is applied to a field or property in an entity class to indicate that an instance of an @Embeddable type is embedded in the parent entity.
The fields of the embedded class will be stored as part of the parent entity’s table.

@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Embedded
    private Address address;  // Address is embedded here

    // getters and setters
}
============================================================================================================================================
What is Optimistic Locking and how do you implement it in Hibernate?
Optimistic Locking is a concurrency control mechanism used to prevent conflicts when multiple transactions attempt to update the same entity simultaneously.
It assumes that conflicts are rare and allows multiple transactions to proceed without locking the entity.
When a transaction tries to commit changes, it checks if the entity has been modified by another transaction since it was last read.
If a conflict is detected, an exception is thrown, and the transaction can be retried or handled accordingly.
To implement Optimistic Locking in Hibernate, you typically use the @Version annotation on a field in your entity class.
This field can be of type int, long, Integer, Long, or java.sql.Timestamp.
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @Version
    private int version;  // Version field for optimistic locking
    // getters and setters
}
============================================================================================================================================
What are the key differences between Hibernate and JPA?
Hibernate is a specific ORM (Object-Relational Mapping) framework, while JPA (Java Persistence API) is a specification for ORM in Java.
API
Hibernate provides its own API (e.g., Session, Transaction).
JPA provides a standard API (e.g., EntityManager, Query).
Configuration
Hibernate requires a Hibernate-specific configuration (hibernate.cfg.xml).
JPA uses persistence.xml for configuration.
Vendor Specific
Hibernate is a specific implementation of JPA, but also offers additional features outside the JPA specification.
JPA is a specification and can be implemented by multiple vendors (e.g., Hibernate, EclipseLink, OpenJPA).
=============================================================================================================================================
How do you handle LazyInitializationException in Hibernate?
The LazyInitializationException occurs when you try to access a lazily-loaded association (e.g., a @OneToMany or @ManyToOne) outside the context of an active session.
This happens because the session is closed before the lazy-loaded entity is accessed.
how can you handle LazyInitializationException in Hibernate?
Initialize the association within the session:
You can eagerly fetch associations when necessary by using fetch = FetchType.EAGER in your mapping.
Alternatively, you can explicitly initialize the collection using Hibernate.initialize() within the session scope.
Using DTOs:
Instead of relying on lazy loading, you can fetch the necessary data eagerly by using a DTO (Data Transfer Object) and
a projection or query that loads all necessary associations in one query.
============================================================================================================================================
Explain how Transaction Isolation Levels work in Hibernate?
Transaction isolation levels define how transactions are isolated from each other in a concurrent environment.
Hibernate allows you to set the isolation level of transactions to control how database reads and writes interact with other concurrent transactions.
READ_UNCOMMITTED: Allows dirty reads, where a transaction can read uncommitted changes from another transaction.
READ_COMMITTED: Prevents dirty reads, but allows non-repeatable reads (a value can change between reads within the same transaction).
REPEATABLE_READ: Prevents dirty and non-repeatable reads, but allows phantom reads (new rows can be inserted by other transactions).
SERIALIZABLE: The highest isolation level, preventing dirty reads, non-repeatable reads, and phantom reads by
locking the entire range of data involved in the transaction.
============================================================================================================================================
Cache Strategies:
READ_ONLY: Data in this cache is never modified; only reads are allowed.
READ_WRITE: Data can be read and written. Changes are synchronized between the cache and the database.
NONSTRICT_READ_WRITE: Data is cached, but updates are not synchronized with the database immediately.
TRANSACTIONAL: Provides transactional guarantees for cache consistency.
============================================================================================================================================
 Explain the concept and implementation of Composite Keys in Hibernate.
 In Hibernate, composite keys are represented using either @IdClass or @EmbeddedId.
 @Entity
 @IdClass(EmployeeId.class)
 public class Employee {

     @Id
     private String department;

     @Id
     private Long employeeNumber;

     private String name;
 }
 public class EmployeeId implements Serializable {
     private String department;
     private Long employeeNumber;

     // equals() and hashCode() methods must be implemented for composite keys.
 }

 @EmbeddedId.->

 @Entity
 public class Employee {
     @EmbeddedId
     private EmployeeId id;

     private String name;
 }
@Embeddable
public class EmployeeId implements Serializable {
    private String department;
    private Long employeeNumber;
}
============================================================================================================================================
How do you manage and configure multi-tenancy in Hibernate?
Multi-tenancy refers to a single instance of a software application serving multiple tenants, with each tenant having their own data and configuration.
Types of Multi-Tenancy:
Database per Tenant:
Each tenant has its own schema or database.
Hibernate uses a MultiTenantConnectionProvider to switch between databases.
Schema per Tenant:
Multiple tenants share the same database but have different schemas.
The MultiTenantConnectionProvider handles the schema switch dynamically.
Discriminator-based (Shared Table):
All tenants share the same schema and table, but a discriminator column is used to distinguish data between tenants.
============================================================================================================================================
What is the role of Interceptor in Hibernate, and when would you use it?
An Interceptor in Hibernate is a way to hook into the lifecycle of an entity.
It allows you to intercept various events, such as before or after an entity is saved, updated, or deleted.
Use cases:

Logging: Logging changes to entities during their lifecycle.
Auditing: Tracking who created or modified an entity and when.
Validation: Perform additional validations before an entity is persisted.
==============================================================================================================================================
How would you implement pagination using Hibernate?
Pagination allows you to retrieve a subset of results from a larger set of data, which is especially useful when dealing with large datasets.
You can implement pagination in Hibernate using the setFirstResult() and setMaxResults() methods on a Query or Criteria object.
============================================================================================================================================
 How does Hibernate deal with Cascading Deletes?
Cascading in Hibernate refers to operations (e.g., save, update, delete) that are automatically applied to related entities.
Cascading deletes ensure that when an entity is deleted, its associated entities (e.g., child entities) are also deleted.

This is done using the @OneToMany or @ManyToMany annotations with the cascade attribute.
@Entity
public class Department {
    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Employee> employees;

    // other fields, getters, and setters
}
============================================================================================================================================
How do you manage Transaction Propagation and Transaction Isolation in Hibernate?
Transaction Propagation defines how transactions should behave in different contexts (e.g., nested transactions).
REQUIRED: Use an existing transaction or create a new one.
REQUIRES_NEW: Always start a new transaction.
MANDATORY: Must join an existing transaction.
SUPPORTS: If a transaction exists, join it; otherwise, continue without a transaction.

Transaction Isolation controls the visibility of changes made by one transaction to other transactions.
READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE (as mentioned earlier).
============================================================================================================================================


