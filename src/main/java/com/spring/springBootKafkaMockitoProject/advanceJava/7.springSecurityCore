Spring Security is a powerful authentication and authorization framework used to secure Java-based web applications.
protection against common vulnerabilities like CSRF, session fixation, and brute-force attacks.

Spring Security is built on four core concepts:
Authorization: Determines user permissions and access control.
Password Storage: Securely manages password encoding and storage.
Authentication: Verifies the user‚Äôs identity.
Servlet Filters: Manages security filters to control requests.

dependency:spring-boot-starter-security

Latest Features in Spring Security 6.4 ->(2025)->
OAuth 2.0 Enhancements: Allows easy integration with third-party login providers like Google, GitHub, and Microsoft.
Improved Reactive Security: Enhanced support for Spring WebFlux and non-blocking security handling.
Advanced Password Encoding: Utilizes DelegatingPasswordEncoder with multiple encoding formats
Unified Request Matchers API: Methods like antMatchers(), mvcMatchers(), and regexMatchers()
are deprecated in favor of requestMatchers().
Enhanced Authorization Rules: More flexible security configurations for role-based and method-level security.
Security Context Propagation: Improved support for security context sharing across different execution models,
including reactive and asynchronous flows.

Spring Security Architecture->
Spring Security framework adds two important capabilities to web applications, which are listed below:
1.Authentication->
Authentication is the process of verifying the identity of the computer user. It is the process of verifying the
user and devices before allowing them to access the resources.
In Java, the AuthenticationManager interface is responsible for handling authentication events.
The AuthenticationManager interface method ‚Äúauthenticate()‚Äù returns authentication (i.e if authentication= true )
if it verifies the identity.
The AuthenticationException is thrown if it identifies an invalid identity or principal.
It returns null if he cannot decide the identity.
2.Authorization/Access Control->
    authority to perform certain tasks or operations.
    In Java, AccessDecisionManager and AccessDecsionVoter classes help in the authorization process.


// Configuration Java File
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableMethodSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    // Bean for UserDetailsService to manage user authentication details
    @Bean
    public UserDetailsService userDetailsService(BCryptPasswordEncoder passwordEncoder) {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("AbhijeetRathore")
                .password(passwordEncoder.encode("Abhijeet123"))
                .roles("USER")
                .build());
        return manager;
    }
    // Bean for configuring HTTP security settings
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/").hasRole("ADMIN")
                .anyRequest().authenticated())
            .httpBasic();
        return http.build();
    }
     // Bean for customizing web security
    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return web -> web.ignoring().requestMatchers("/resources/**");
    }
    // Bean to provide a BCryptPasswordEncoder for securely encoding passwords
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


Spring Security Annotations->
1. @Secured-is used to specify a list of roles that are allowed to access a method or class.
@Secured({ "ROLE_ADMIN", "ROLE_SUPER_ADMIN" })
public void createUser(User user)
{
    // ... logic for create User
}

2.@PreAuthorize-
The @PreAuthorize annotation is used to specify an expression that must be evaluated to be true in order for
a method or class to be accessible. The expression is written in Spring Expression Language (SpEL).
The @PreAuthorize annotation can be used to control access to methods, classes, and even entire applications.
@PreAuthorize("hasRole('ROLE_ADMIN')")
public void deleteAdminUser(Long userId)
{
    // ... logic for delete User
}

3.@PostAuthorize
The @PostAuthorize annotation is used to specify an expression that must be evaluated to true after a method or
class has been executed. The expression is written in SpEL.
The @PostAuthorize annotation can be used to control the results of a method or class.
@PostAuthorize(
    "hasRole('ROLE_ADMIN') and hasPermission(returnObject, 'read:courses')")
public List<Course>
findAllCourses()
{
    // ... logic for find all courses
}

4. @PreFilter
The @PreFilter annotation is used to specify an expression that must be evaluated to true in order for a method or class
to be included in a security filter chain. The expression is written in SpEL
@PreFilter(
    "hasRole('ROLE_ADMIN') and hasPermission(filterObject, 'read:courses')")
public void
deleteCourses(List<Course> courses)
{
    // ... logic for delete Courses
}

5. @PostFilter
The @PostFilter annotation is used to specify an expression that must evaluate to true after a method or class
has been executed in order for it to be included in a security filter chain.
@PostFilter(
    "hasRole('ROLE_ADMIN') and hasPermission(filterObject, 'read:classes')")
public List<Class>
findAllClasses()
{
    // ...logic for find all classes
}

6. @RolesAllowed
The @RolesAllowed annotation is more flexible than the @Secured annotation because it allows you to specify an
expression that evaluates to a list of roles. This expression can be written in Spring Expression Language (SpEL).
@RolesAllowed("ROLE_ADMIN")
public void deleteCourse(Long courseId)
{
    // ... logic for delete course
}

7.@AuthenticationPrincipal->
that is used to inject the current authenticated user into a method or class.
The user is injected as a Spring Security Authentication object.
@GetMapping("/username")
public String getUsername(@AuthenticationPrincipal String username) {
  // ...
}

8.@RoleHierarchy
can be used to simplify the security configuration of your Spring application. By defining a role hierarchy,
you can reduce the number of @RolesAllowed or @PreAuthorize annotations that you need to write.
@RoleHierarchy(value = { "ROLE_ADMIN > ROLE_USER",
                         "ROLE_SUPER_ADMIN > ROLE_ADMIN" })

Spring Security Expressions->
Method Security: Securing methods using annotations like @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter.
Web Security: Configuring HTTP security in the security configuration file using expressions like hasRole(),
hasAnyRole(), hasAuthority(), and permitAll().

Web Security:
In web applications, these expressions are used to secure HTTP requests. Developers can specify which roles or
conditions are required to access certain URL patterns directly in the security configuration.
For example, role-based permissions for the application

Dynamic Data Access:
Security expressions can enable dynamic filtering of data, ensuring that users only access data for which they have
permission. For example, a user may be allowed to view or modify only their own data, not data belonging to other users.


SecurityFilterChainExample->
 @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/restricted/**").authenticated()
                .anyRequest().denyAll()
            )
            .formLogin(form -> form
                .loginProcessingUrl("/api/signin")
                .failureHandler(authenticationFailureHandler())
            )
            .csrf(csrf -> csrf.disable());
        return http.build();
    }

Authentication check->
 @PostMapping("/signin")
    public ResponseEntity<String> signIn(@RequestBody SigninRequest signInRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(signInRequest.getUsername(), signInRequest.getPassword())
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);
            return ResponseEntity.ok("User authenticated successfully!");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Authentication failed: " + e.getMessage());
        }
    }

 springSecuritySessionManagement-

 @Configuration
 @EnableWebSecurity
 public class SecurityConfig  {

     protected void configure(HttpSecurity http) throws Exception {
         http
                 .authorizeRequests()
                 .anyRequest().authenticated()
                 .and()
                 .formLogin()
                 .loginPage("/login").permitAll()
                 .defaultSuccessUrl("/home", true)
                 .and()
                 .logout()
                 .logoutSuccessUrl("/login?logout")
                 .and()
                 .sessionManagement()
                 .maximumSessions(1)// only one session
                 .maxSessionsPreventsLogin(true);
     }
 }

UserDetailsService->
UserDetailsService interface is a core component used for loading user-specific data
It is responsible for retrieving user information from a backend data source, such as a database or an external service,
and returning an instance of the UserDetails interface.
The UserDetailsService interface has a single method called loadUserByUsername(),
which takes a username as a parameter and returns a fully populated UserDetails object.
InMemoryUserDetailsManager class, which is an implementation of the UserDetailsService interface that stores user
details in memory.

User class->User class, which is a convenient builder class provided by the framework for creating instances of UserDetails.
The User class provides a fluent API for constructing UserDetails objects with various attributes.
================================================================================================================================
Explain Spring Security architecture and its core components

Spring Security is built on a chain of filters (Filter Chain Proxy) that intercepts HTTP requests. Core components include:

SecurityContextHolder: Thread-local storage holding SecurityContext
SecurityContext: Contains Authentication object
Authentication: Represents authenticated principal with authorities
AuthenticationManager: Coordinates authentication attempts
ProviderManager: Default implementation delegating to AuthenticationProviders
AuthenticationProvider: Performs actual authentication
UserDetailsService: Loads user-specific data
GrantedAuthority: Represents permissions/roles

Flow:
Request hits FilterChainProxy
Goes through security filter chain (15+ filters)
Authentication filter extracts credentials
AuthenticationManager delegates to appropriate provider
Provider validates and returns Authentication object
SecurityContext stores authentication
Request proceeds to controller
================================================================================================================================
 What are the key filters in Spring Security filter chain and their order?
 1. ChannelProcessingFilter - HTTP/HTTPS switching
 2. SecurityContextPersistenceFilter - Establishes SecurityContext
 3. ConcurrentSessionFilter - Session management
 4. HeaderWriterFilter - Security headers
 5. CsrfFilter - CSRF protection
 6. LogoutFilter - Logout handling
 7. UsernamePasswordAuthenticationFilter - Form login
 8. BasicAuthenticationFilter - Basic auth
 9. RequestCacheAwareFilter - Request caching
 10. SecurityContextHolderAwareRequestFilter - Servlet API integration
 11. AnonymousAuthenticationFilter - Anonymous users
 12. SessionManagementFilter - Session fixation protection
 13. ExceptionTranslationFilter - Exception handling
 14. FilterSecurityInterceptor - Authorization decisions
 ================================================================================================================================
 How does Authentication and Authorization work internally?
 Authentication Flow:
 // When credentials arrive
 1. Filter creates UsernamePasswordAuthenticationToken (unauthenticated)
 2. AuthenticationManager.authenticate() called
 3. DaoAuthenticationProvider:
    - Calls UserDetailsService.loadUserByUsername()
    - Compares password using PasswordEncoder
    - Returns authenticated token with authorities
 4. SecurityContextHolder.getContext().setAuthentication()

Authorization Flow:
 When secured resource accessed
1. FilterSecurityInterceptor intercepts
2. Calls AccessDecisionManager
3. AccessDecisionVoters vote (GRANT/DENY/ABSTAIN)
4. If granted, request proceeds
5. If denied, AccessDeniedException thrown
================================================================================================================================
 What is JWT structure and how does each part work?
 JWT has three parts separated by dots: header.payload.signature
1. Header:
   - Specifies token type (JWT) and signing algorithm (e.g., HS256)
   - Example: {"alg":"HS256","typ":"JWT"}
   - Base64Url encoded
2.  Payload:
   {
     "sub": "user123",           // Subject (user ID)
     "iat": 1516239022,          // Issued at
     "exp": 1516242622,          // Expiration
     "iss": "myapp.com",         // Issuer
     "roles": ["USER", "ADMIN"]  // Custom claims
   }
3. Signature:
   - Created by signing the header and payload with a secret key
   - Ensures token integrity and authenticity
   - HMACSHA256(
       base64UrlEncode(header) + "." + base64UrlEncode(payload),
       secret
     )

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain)
            throws ServletException, IOException {

        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(jwtAuthenticationEntryPoint))
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthenticationFilter,
                           UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
================================================================================================================================
How to handle JWT token expiration and blacklisting?
@Service
public class TokenBlacklistService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Autowired
    private JwtTokenProvider tokenProvider;

    public void blacklistToken(String token) {
        Date expiration = tokenProvider.getExpirationFromToken(token);
        long timeToLive = expiration.getTime() - System.currentTimeMillis();

        if (timeToLive > 0) {
            redisTemplate.opsForValue().set(
                "blacklist:" + token,
                "blacklisted",
                timeToLive,
                TimeUnit.MILLISECONDS
            );
        }
    }

    public boolean isBlacklisted(String token) {
        return redisTemplate.hasKey("blacklist:" + token);
    }
}
================================================================================================================================
How does JWT work with LDAP authentication? Explain complete flow
1. User Login Request:
   - User submits credentials (username/password) to the application.
2. LDAP Authentication:
   - Application uses Spring Security's LDAP authentication provider to validate credentials against the LDAP server.
   - If valid, LDAP server returns user details (DN, attributes).
3. JWT Generation:
   - Application generates a JWT containing user information and roles.
   - Signs the JWT with a secret key.
4. Token Delivery:
   - JWT is sent back to the client in the response.
5. Subsequent Requests:
   - Client includes JWT in the Authorization header for future requests.
6. JWT Validation:
   - Application intercepts requests, extracts JWT, and validates signature and expiration.
   - If valid, retrieves user details from JWT.
7. Authorization:
   - Application checks user roles/permissions from JWT for access control.

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated())
            .ldapAuthentication(ldap -> ldap
                .userDnPatterns("uid={0},ou=people")
                .groupSearchBase("ou=groups")
                .contextSource(context -> context
                    .url("ldap://localhost:8389/dc=springframework,dc=org")
                    .managerDn("uid=admin,ou=system")
                    .managerPassword("secret"))
                .passwordCompare(compare -> compare
                    .passwordEncoder(new LdapShaPasswordEncoder())
                    .passwordAttribute("userPassword")))
            .addFilterBefore(jwtAuthenticationFilter(),
                           UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }
}
========================================================================================================================
Explain SecurityContext and SecurityContext Holder in Spring security.
In Spring Security, the SecurityContext is where details about the currently authenticated user are
stored, like user details and granted authorities.
The SecurityContextHolder is a helper class that holds the SecurityContext. It's like a container or
storage space that keeps track of the authentication information of the current user throughout the
application.
This makes it easy to access the user's details anywhere in the application, ensuring that security
decisions can be made based on the user's authentication status and roles.
========================================================================================================================
What do you mean by OAuth2 Authorization code grant type
The OAuth2 Authorization Code grant type is a secure way to authenticate and authorize users. It
works by directing the user to a login page managed by the OAuth2 provider (like Google or
Facebook).
After logging in, the user is given a code.
This code is then exchanged for an access token by the application's backend server. This access
token is used to access the user's data securely.
This process keeps user credentials safe, as the actual token exchange happens away from the user's
device, minimizing the risk of sensitive information being exposed.
========================================================================================================================
How does Spring Security protect against Cross-Site Request Forgery (CSRF) attacks, and under
what circumstances might you disable CSRF protection?
Spring Security protects against CSRF attacks by generating unique tokens for each session and
requiring that each request from the client includes this token.
This ensures the request is from the authenticated user, not a malicious site. However, CSRF
protection might be disabled for APIs meant to be accessed by non-browser clients, like mobile apps
or other back-end services, where the risk of CSRF is low and tokens can't be easily managed.
Disabling CSRF in these cases simplifies the integration with these services without significantly
compromising security.
========================================================================================================================
How can you implement method-level security in a Spring application, and what are the
advantages of this approach?
To implement method-level security in a Spring application, I can use annotations like @PreAuthorize
or @Secured on individual methods. These annotations check if the user has the required
permissions or roles before executing the method.
The advantage of this approach is that it provides fine-grained control over who can access specific
functionalities within the application. This means I can restrict sensitive operations at the method
level, ensuring that only authorized users can perform certain actions, which enhances the overall
security of the application
========================================================================================================================
Your organization uses an API Gateway to route requests to various microservices. How would
you leverage Spring Security to authenticate and authorize requests at the gateway level before
forwarding them to downstream services?
At the API Gateway, I can use Spring Security to check if requests are allowed before sending them to
other services.
By checking tokens or using OAuth2 at the gateway, I make sure only valid and authorized requests
get through.
This means each service doesn't have to check security separately, making the whole system simpler
and safer
========================================================================================================================
 How can you use Spring Expression Language (SpEL) for finegrained access control?
I can use Spring Expression Language (SpEL) for fine-grained access control by embedding it in
security annotations like @PreAuthorize. For example, I can write expressions that check if a user has
specific roles, and permissions, or even match against method parameters to decide access.
This allows for very detailed and flexible security rules directly in the code, letting me tailor access
rights precisely to the user's context and the operation being performed. Using SpEL in this way helps
in creating dynamic and complex security conditions without cluttering the business logic.
========================================================================================================================
 In your application, there are two types of users: ADMIN and USER. Each type should have
access to different sets of API endpoints. Explain how you would configure Spring Security to
enforce these access controls based on the user's role.
In the application, to control who can access which API endpoints, I can use Spring Security to set
rules based on user roles. I can configure it so that only ADMIN users can reach adminrelated
endpoints and USER users can access user-related endpoints.
This is done by defining patterns in the security settings, where I link certain URL paths with specific
roles, like making all paths starting with "/admin" accessible only to users with the ADMIN role, and
paths starting with "/user" accessible to those with the USER role. This way, each type of user gets
access to the right parts of the application
========================================================================================================================
What do you mean by digest authentication?
Digest authentication is a way to check who is trying to access something online without sending
their actual password over the internet. Instead, it sends a hashed (scrambled) version of the
password along with some other information.
When the server gets this scrambled password, it compares it with its own scrambled version. If they
match, it means the user's identity is verified, and access is granted. This method is more secure
because the real password is never exposed during the check.
========================================================================================================================
) What is the best practice for storing passwords in a Spring Security application?
The best practice for storing passwords in a Spring Security application is to never store plaintext
passwords. Instead, passwords should be hashed using a strong, one-way hashing algorithm like
bcrypt, which Spring Security supports.
Hashing converts the password into a unique, fixed-size string that cannot be easily reversed.
Additionally, using a salt (a random value added to the password before hashing) makes the hash
even more secure by preventing attacks like rainbow table lookups. This way, even if the password
data is compromised, the actual passwords remain protected.
========================================================================================================================
Explain the purpose of the Spring Security filter chain and How would you add or customize a
filter within the Spring Security filter chain
The Spring Security filter chain is a series of filters that handle authentication and authorization in a
Spring application. Each filter has a specific task, like checking login credentials or verifying if a user
has access to certain resources.
To add or customize a filter, I can define a new filter class and add it to the filter chain in the security
configuration. This is done by using the addFilterBefore, addFilterAfter, or addFilterAt methods,
specifying where in the chain the new filter should be placed, to ensure it's executed at the correct
point during the security processing.
========================================================================================================================
How does Spring Security handle session management, and what are the options for handling
concurrent sessions
Spring Security handles session management by creating a session for the user upon successful
authentication. For managing concurrent sessions, it provides options to control how many sessions
a user can have at once and what happens when the limit is exceeded.
For example, I can configure it to prevent new logins if the user already has an active session or to
end the oldest session. This is managed through the session management settings in the Spring
Security configuration, where I can set policies like maximumSessions to limit the number of
concurrent sessions per user
========================================================================================================================
You've encountered an issue where users are being unexpectedly denied access to a resource
they should have access to. Describe your approach to debugging this issue in a Spring Securityenabled application.
To debug access issues in a Spring Security-enabled application, I would start by checking the security
configuration to ensure the correct roles and permissions are set for the resource. Next, I would
examine the logs to see if Spring Security is throwing any specific errors or denying access for a
particular reason.
I might also enable debug logging for Spring Security to get more detailed information about the
security decisions being made. Additionally, verifying the user's assigned roles and the methodlevel
security annotations, if any, would help identify if the access rules are correctly applied.
========================================================================================================================
Describe how to implement dynamic access-control policies in Spring Security.
To implement dynamic access-control policies in Spring Security, We can use the Spring Expression
Language (SpEL) within the @PreAuthorize or @PostAuthorize annotations to define complex,
runtime-evaluated conditions for access control.
This allows the access rules to be determined based on the current state of the application, user
properties, or method parameters. For example, by fetching roles or permissions from a database at
runtime, we can dynamically decide whether a user can access a specific method or resource,
allowing for more flexible and context-sensitive security policies.
========================================================================================================================
How do you test security configurations in Spring applications?
To test security configurations in Spring applications, I use Spring Security's testing support, which
includes annotations like @WithMockUser or @WithAnonymousUser to simulate different
authentication scenarios.
I also write unit and integration tests that make requests to secured endpoints and verify the
responses based on various user roles and permissions.
By using MockMvc in Spring MVC tests, I can assert that the security rules are correctly enforced,
checking if the access is granted or denied as expected. This ensures that the security configuration is
working properly and protecting the application as intended.
========================================================================================================================
Explain salting and its usage in spring security
Salting in Spring Security means adding a random piece of data to a password before turning it into a
hash, a kind of scrambled version.
This makes every user's password hash unique, even if the actual passwords are the same. It helps
stop attackers from guessing passwords using known hash lists.
When a password needs to be checked, it's combined with its salt again, hashed, and then compared
to the stored hash to see if the password is correct. This way, the security of user passwords is
greatly increased.
========================================================================================================================
Explain what is AuthenticationManager and ProviderManager in Spring security.
The AuthenticationManager in Spring Security is like a checkpoint that checks if user login details are
correct. The ProviderManager is a specific type of this checkpoint that uses a list of different ways
(providers) to check the login details.
It goes through each way to find one that can confirm the user‚Äôs details are valid. This setup lets
Spring Security handle different login methods, like checking against a database or an online service,
making sure the user is who they say they are.
========================================================================================================================
 When a user tries to access a resource without the necessary permissions, you want to redirect
them to a custom "access denied" page instead of displaying the default Spring Security error
message. How would you achieve this in your Spring Security configuration?
To redirect users to a custom "access denied" page in Spring Security, I would configure the
ExceptionTranslationFilter within my security settings.
Specifically, I would set a custom access denied handler using the accessDeniedHandler method,
providing it with a URL to my custom page.
This handler intercepts the AccessDeniedException and redirects the user to the specified page,
allowing for a more user-friendly error experience. By customizing the access denied response, I can
provide clearer information or instructions to the user, improving the overall usability of the application.
========================================================================================================================
How would you secure REST API? Please share all methods step by step
How would you secure REST API? Please share all methods step by step.
To secure a REST API, you can start by using HTTPS to encrypt data between the client
and server, ensuring that all data transferred is secure from eavesdropping. Next,
implement authentication mechanisms like OAuth to control who can access the API,
verifying user identities before allowing access to sensitive data. Lastly, use input
validation to protect the API from malicious data, ensuring that all incoming data is
checked for validity before being processed. This approach helps maintain the security
and integrity of the API by addressing encryption, access control, and data validation.
========================================================================================================================
What is SLF4J logging?
SLF4J (Simple Logging Facade for Java) is a Java library that serves as an interface for
various logging frameworks, allowing developers to use a single logging API while
choosing different logging implementations at deployment time. It acts as a simple
facade or abstraction for various logging frameworks, such as log4j and java.util.logging,
which means we can swap the logging framework without changing our main code. This
flexibility helps in maintaining and managing the logging capabilities of a Java application
more efficiently.
========================================================================================================================
What details are present in a JWT token?
A JWT (JSON Web Token) contains three main parts: the header, the payload, and the
signature. The header describes the token's type and the algorithm used for signing. The
payload includes claims, which are statements about the user like their ID and
permissions, along with metadata such as token issuance and expiration times. The
signature ensures the token hasn‚Äôt been altered, providing security and authenticity. This
format makes JWTs a secure way to transmit user information
========================================================================================================================
Can you explain how to use method-level security in Spring Boot?
Method-level security in Spring Boot is enabled using Spring Security annotations. First,
activate it with @EnableGlobalMethodSecurity in our configuration. Then, apply
annotations like @PreAuthorize or @Secured to your methods. These specify security
conditions, such as roles required to execute the method, ensuring that only authorized
users can access specific functionalities
For method-level security, I would enable it by adding
@EnableGlobalMethodSecurity(prePostEnabled = true) to the security configuration
class. Then, I can use annotations like @PreAuthorize or @Secured on the service
methods, for example:
@PreAuthorize("hasRole('ADMIN')")
public void adminOnlyMethod() {}
========================================================================================================================
What are the differences between method security and URL security in Spring
Security?
In Spring Security, URL security and method security serve different purposes. URL
security controls access to different parts of our application based on the URL patterns;
it's set up in the security configuration to restrict which roles or authenticated users can
access specific endpoints. Method security, on the other hand, is used to secure
individual methods within our code using annotations, providing more granular control
over who can execute specific functions based on roles or complex logic. This allows
precise and context-specific security configurations within the application.
========================================================================================================================
Your application requires stateless authentication for RESTful services. How would
you implement JSON Web Token (JWT) authentication using Spring Security? Describe
the flow from user login to accessing protected resources.
To implement JWT authentication, I would follow these steps:
1. User Login: When a user logs in, the application validates their credentials. If valid, it
generates a JWT token containing user details and roles.
2. Token Return: The token is returned to the client, usually in the response body.
3. Accessing Resources: For subsequent requests, the client includes the token in the
Authorization header.
4. Token Validation: On the server side, a filter intercepts requests, extracts the token,
and validates it. If valid, the user is granted access to protected resources
========================================================================================================================
In your application, you need to securely store user passwords. What approach
would you take to implement password encoding in Spring Security? Discuss the choice
of encoding algorithm and how to verify passwords during authentication.
I would use Spring Security's PasswordEncoder interface to encode passwords. The
recommended algorithm is BCrypt, which offers a good balance of security and
performance. To encode a password, I would use:
PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
String encodedPassword = passwordEncoder.encode(rawPassword);
During authentication, I would verify the password using:
boolean isMatch = passwordEncoder.matches(rawPassword, encodedPassword);
This ensures that user passwords are stored securely and can be verified correctly during login
========================================================================================================================
Full End-to-End Flow (Interview-Ready Notes)
STAGE 1: User initiates login from frontend
What happens
User clicks ‚ÄúLogin‚Äù
Frontend ‚Üí Okta Authorization Endpoint (/authorize)

Who is responsible

Frontend ‚Üí initiates OAuth flow

Okta Authorization Server ‚Üí handles authentication

What Okta does

Displays login page

Authenticates user (password / MFA)

Validates:

client_id

redirect_uri

Generates authorization code

Key point

Backend is not involved

No token exists yet

üëâ Interview line

‚ÄúAuthentication starts at the frontend; the backend never handles user login.‚Äù

STAGE 2: Okta redirects back with authorization code
What happens
Okta ‚Üí Frontend redirect_uri
?code=abc123

Who is responsible

Okta

Why this is important

Authorization code is short-lived

Prevents token exposure in browser

STAGE 3: Frontend exchanges code for tokens
What happens
Frontend ‚Üí Okta Token Endpoint (/token)

Who is responsible

Frontend

Okta Authorization Server

What Okta returns

Access Token (JWT)

ID Token

(Optional) Refresh Token

Key point

PKCE ensures only the same client can exchange the code

üëâ Interview line

‚ÄúTokens are issued only after successful code verification using PKCE.‚Äù

backend->

STAGE 1: Request enters backend
What happens
Client ‚Üí Backend API
Authorization: Bearer <JWT>

Who is responsible

Spring Security Filter Chain

FILTER 1: BearerTokenAuthenticationFilter ‚úÖ (MANDATORY)
Why this filter exists

To extract OAuth2 Bearer token from request

What happens internally

Reads HTTP header:

Authorization: Bearer eyJ...


If token is missing ‚Üí request continues as unauthenticated

If token is present ‚Üí passes token to AuthenticationManager

Failure case

Malformed token ‚Üí 401 Unauthorized

üëâ Interview line

‚ÄúThis filter is responsible for extracting the JWT from the Authorization header.‚Äù

FILTER 2: JwtAuthenticationProvider ‚úÖ (MANDATORY)
Why this exists

To validate the JWT issued by Okta

What happens internally
1Ô∏è‚É£ Signature validation

Fetches public key from Okta JWKS endpoint
https://{yourOktaDomain}/oauth2/{authServerId}/v1/keys
{
  "keys": [
    {
      "kid": "1676",
      "kty": "RSA",
      "alg": "RS256",
      "n": "sXchJ9...",
      "e": "AQAB"
    }
  ]
}
n ‚Üí RSA modulus

e ‚Üí RSA exponent

Together they form the public key

üëâ Interview line

‚ÄúThe backend fetches Okta‚Äôs public keys from the JWKS endpoint and matches the kid.‚Äù

Public key caching (VERY IMPORTANT)
What Spring Security does

Fetches JWKS once

Caches public keys in memory

Refreshes automatically when:

New kid appears

Cache expires

üëâ Interview gold

‚ÄúPublic keys are cached, so Okta is not called on every request.‚Äù

What is the role of kid in JWT?->
kid (Key ID) identifies which cryptographic key was used to sign the JWT,
so the resource server knows which public key to use for signature verification.

Where kid exists
In the JWT header
{
  "alg": "RS256",
  "kid": "1676"
}


alg ‚Üí signing algorithm
kid ‚Üí key identifier

Verifies JWT signature

2Ô∏è‚É£ Claim validation

Validates:

iss ‚Üí token issued by Okta

aud ‚Üí token meant for this API

exp ‚Üí token not expired

‚ùå Any failure ‚Üí 401 Unauthorized

üëâ Interview line

‚ÄúToken validation is done locally using Okta‚Äôs public key, without calling Okta for every request.‚Äù

FILTER 3: JwtAuthenticationConverter ‚úÖ (MANDATORY)
Why this exists

To convert JWT ‚Üí Spring Authentication

What happens

Extracts claims:

subject

scopes

groups

Maps them to:

Principal + GrantedAuthorities


Example:

scp = orders.read ‚Üí SCOPE_orders.read


üëâ Interview line

‚ÄúJWT claims are converted into Spring Security authorities for authorization checks.‚Äù

FILTER 4: SecurityContextHolderFilter ‚úÖ (MANDATORY)
Why this exists

To store authenticated user in SecurityContext

What happens

Saves Authentication object in:

SecurityContextHolder (ThreadLocal)


Makes authentication available throughout request

üëâ Interview line

‚ÄúAfter this filter, Spring considers the request authenticated.‚Äù

FILTER 5: AuthorizationFilter ‚úÖ (MANDATORY)
Why this exists

To enforce access control

What happens

Evaluates:

URL rules

@PreAuthorize

hasAuthority()

Example:

@PreAuthorize("hasAuthority('SCOPE_orders.read')")

Failure case

Authenticated but not authorized ‚Üí 403 Forbidden

üëâ Interview gold

‚Äú401 means authentication failure, 403 means authorization failure.‚Äù

STAGE FINAL: Controller Execution
What happens

Request reaches controller

Authentication is available

Authentication auth =
SecurityContextHolder.getContext().getAuthentication();

Filter Chain Order (MEMORIZE THIS)
BearerTokenAuthenticationFilter
        ‚Üì
JwtAuthenticationProvider
        ‚Üì
JwtAuthenticationConverter
        ‚Üì
SecurityContextHolderFilter
        ‚Üì
AuthorizationFilter
        ‚Üì
Controller

========================================================================================================================
Easy Difference: JWT vs OAuth 2.0
Topic	JWT-based Security	OAuth 2.0-based Security
What it is	A token format ,	A security flow / process
Think of it as	A sealed envelope with user info,	A rulebook for giving access
Purpose	Carry user data securely,	Decide who can access what
Handles login?	‚ùå No	‚úÖ Yes
Handles permissions?	Limited	‚úÖ, Yes (scopes)
Token structure	Fixed (header, payload, signature),	Not fixed
Who creates it	Any system,	Authorization Server (Okta, Auth0)
Used alone?	Can be,	Rarely (not recommended)
Common usage	Internal services,	Enterprise login & SSO
Very Simple Analogy (BEST FOR INTERVIEW)
JWT = ID Card

Contains name, ID, expiry

Signed so it can‚Äôt be tampered with

OAuth 2.0 = Security Process

Defines:

how ID card is issued

who can get it

how it should be used

üëâ OAuth2 gives you the ID card, JWT defines how the card looks

How They Work Together (Real Life)

In systems like Okta:

OAuth 2.0 decides:

user logs in

permissions (scopes)

Okta issues a JWT token

Backend verifies JWT

üëâ OAuth2 = process, JWT = token

Common Interview Mistake (Avoid This)

‚ùå ‚ÄúJWT is better than OAuth2‚Äù
‚ùå ‚ÄúOAuth2 replaces JWT‚Äù

‚úÖ Correct:

‚ÄúOAuth2 often uses JWT, but JWT alone is not OAuth2.‚Äù

One-Line Explanation (MEMORIZE)

‚ÄúOAuth 2.0 defines how access is given, and JWT is the token used to carry that access information.‚Äù















