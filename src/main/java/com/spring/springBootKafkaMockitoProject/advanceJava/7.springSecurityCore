Spring Security is a powerful authentication and authorization framework used to secure Java-based web applications.
protection against common vulnerabilities like CSRF, session fixation, and brute-force attacks.

Spring Security is built on four core concepts:
Authorization: Determines user permissions and access control.
Password Storage: Securely manages password encoding and storage.
Authentication: Verifies the user’s identity.
Servlet Filters: Manages security filters to control requests.

dependency:spring-boot-starter-security

Latest Features in Spring Security 6.4 ->(2025)->
OAuth 2.0 Enhancements: Allows easy integration with third-party login providers like Google, GitHub, and Microsoft.
Improved Reactive Security: Enhanced support for Spring WebFlux and non-blocking security handling.
Advanced Password Encoding: Utilizes DelegatingPasswordEncoder with multiple encoding formats
Unified Request Matchers API: Methods like antMatchers(), mvcMatchers(), and regexMatchers()
are deprecated in favor of requestMatchers().
Enhanced Authorization Rules: More flexible security configurations for role-based and method-level security.
Security Context Propagation: Improved support for security context sharing across different execution models,
including reactive and asynchronous flows.

Spring Security Architecture->
Spring Security framework adds two important capabilities to web applications, which are listed below:
1.Authentication->
Authentication is the process of verifying the identity of the computer user. It is the process of verifying the
user and devices before allowing them to access the resources.
In Java, the AuthenticationManager interface is responsible for handling authentication events.
The AuthenticationManager interface method “authenticate()” returns authentication (i.e if authentication= true )
if it verifies the identity.
The AuthenticationException is thrown if it identifies an invalid identity or principal.
It returns null if he cannot decide the identity.
2.Authorization/Access Control->
    authority to perform certain tasks or operations.
    In Java, AccessDecisionManager and AccessDecsionVoter classes help in the authorization process.


// Configuration Java File
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableMethodSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    // Bean for UserDetailsService to manage user authentication details
    @Bean
    public UserDetailsService userDetailsService(BCryptPasswordEncoder passwordEncoder) {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("AbhijeetRathore")
                .password(passwordEncoder.encode("Abhijeet123"))
                .roles("USER")
                .build());
        return manager;
    }
    // Bean for configuring HTTP security settings
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/").hasRole("ADMIN")
                .anyRequest().authenticated())
            .httpBasic();
        return http.build();
    }
     // Bean for customizing web security
    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return web -> web.ignoring().requestMatchers("/resources/**");
    }
    // Bean to provide a BCryptPasswordEncoder for securely encoding passwords
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


Spring Security Annotations->
1. @Secured-is used to specify a list of roles that are allowed to access a method or class.
@Secured({ "ROLE_ADMIN", "ROLE_SUPER_ADMIN" })
public void createUser(User user)
{
    // ... logic for create User
}

2.@PreAuthorize-
The @PreAuthorize annotation is used to specify an expression that must be evaluated to be true in order for
a method or class to be accessible. The expression is written in Spring Expression Language (SpEL).
The @PreAuthorize annotation can be used to control access to methods, classes, and even entire applications.
@PreAuthorize("hasRole('ROLE_ADMIN')")
public void deleteAdminUser(Long userId)
{
    // ... logic for delete User
}

3.@PostAuthorize
The @PostAuthorize annotation is used to specify an expression that must be evaluated to true after a method or
class has been executed. The expression is written in SpEL.
The @PostAuthorize annotation can be used to control the results of a method or class.
@PostAuthorize(
    "hasRole('ROLE_ADMIN') and hasPermission(returnObject, 'read:courses')")
public List<Course>
findAllCourses()
{
    // ... logic for find all courses
}

4. @PreFilter
The @PreFilter annotation is used to specify an expression that must be evaluated to true in order for a method or class
to be included in a security filter chain. The expression is written in SpEL
@PreFilter(
    "hasRole('ROLE_ADMIN') and hasPermission(filterObject, 'read:courses')")
public void
deleteCourses(List<Course> courses)
{
    // ... logic for delete Courses
}

5. @PostFilter
The @PostFilter annotation is used to specify an expression that must evaluate to true after a method or class
has been executed in order for it to be included in a security filter chain.
@PostFilter(
    "hasRole('ROLE_ADMIN') and hasPermission(filterObject, 'read:classes')")
public List<Class>
findAllClasses()
{
    // ...logic for find all classes
}

6. @RolesAllowed
The @RolesAllowed annotation is more flexible than the @Secured annotation because it allows you to specify an
expression that evaluates to a list of roles. This expression can be written in Spring Expression Language (SpEL).
@RolesAllowed("ROLE_ADMIN")
public void deleteCourse(Long courseId)
{
    // ... logic for delete course
}

7.@AuthenticationPrincipal->
that is used to inject the current authenticated user into a method or class.
The user is injected as a Spring Security Authentication object.
@GetMapping("/username")
public String getUsername(@AuthenticationPrincipal String username) {
  // ...
}

8.@RoleHierarchy
can be used to simplify the security configuration of your Spring application. By defining a role hierarchy,
you can reduce the number of @RolesAllowed or @PreAuthorize annotations that you need to write.
@RoleHierarchy(value = { "ROLE_ADMIN > ROLE_USER",
                         "ROLE_SUPER_ADMIN > ROLE_ADMIN" })

Spring Security Expressions->
Method Security: Securing methods using annotations like @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter.
Web Security: Configuring HTTP security in the security configuration file using expressions like hasRole(),
hasAnyRole(), hasAuthority(), and permitAll().

Web Security:
In web applications, these expressions are used to secure HTTP requests. Developers can specify which roles or
conditions are required to access certain URL patterns directly in the security configuration.
For example, role-based permissions for the application

Dynamic Data Access:
Security expressions can enable dynamic filtering of data, ensuring that users only access data for which they have
permission. For example, a user may be allowed to view or modify only their own data, not data belonging to other users.


SecurityFilterChainExample->
 @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/restricted/**").authenticated()
                .anyRequest().denyAll()
            )
            .formLogin(form -> form
                .loginProcessingUrl("/api/signin")
                .failureHandler(authenticationFailureHandler())
            )
            .csrf(csrf -> csrf.disable());
        return http.build();
    }

Authentication check->
 @PostMapping("/signin")
    public ResponseEntity<String> signIn(@RequestBody SigninRequest signInRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(signInRequest.getUsername(), signInRequest.getPassword())
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);
            return ResponseEntity.ok("User authenticated successfully!");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Authentication failed: " + e.getMessage());
        }
    }

 springSecuritySessionManagement-

 @Configuration
 @EnableWebSecurity
 public class SecurityConfig  {

     protected void configure(HttpSecurity http) throws Exception {
         http
                 .authorizeRequests()
                 .anyRequest().authenticated()
                 .and()
                 .formLogin()
                 .loginPage("/login").permitAll()
                 .defaultSuccessUrl("/home", true)
                 .and()
                 .logout()
                 .logoutSuccessUrl("/login?logout")
                 .and()
                 .sessionManagement()
                 .maximumSessions(1)// only one session
                 .maxSessionsPreventsLogin(true);
     }
 }

UserDetailsService->
UserDetailsService interface is a core component used for loading user-specific data
It is responsible for retrieving user information from a backend data source, such as a database or an external service,
and returning an instance of the UserDetails interface.
The UserDetailsService interface has a single method called loadUserByUsername(),
which takes a username as a parameter and returns a fully populated UserDetails object.
InMemoryUserDetailsManager class, which is an implementation of the UserDetailsService interface that stores user
details in memory.

User class->User class, which is a convenient builder class provided by the framework for creating instances of UserDetails.
The User class provides a fluent API for constructing UserDetails objects with various attributes.
================================================================================================================================
Explain Spring Security architecture and its core components

Spring Security is built on a chain of filters (Filter Chain Proxy) that intercepts HTTP requests. Core components include:

SecurityContextHolder: Thread-local storage holding SecurityContext
SecurityContext: Contains Authentication object
Authentication: Represents authenticated principal with authorities
AuthenticationManager: Coordinates authentication attempts
ProviderManager: Default implementation delegating to AuthenticationProviders
AuthenticationProvider: Performs actual authentication
UserDetailsService: Loads user-specific data
GrantedAuthority: Represents permissions/roles

Flow:
Request hits FilterChainProxy
Goes through security filter chain (15+ filters)
Authentication filter extracts credentials
AuthenticationManager delegates to appropriate provider
Provider validates and returns Authentication object
SecurityContext stores authentication
Request proceeds to controller
================================================================================================================================
 What are the key filters in Spring Security filter chain and their order?
 1. ChannelProcessingFilter - HTTP/HTTPS switching
 2. SecurityContextPersistenceFilter - Establishes SecurityContext
 3. ConcurrentSessionFilter - Session management
 4. HeaderWriterFilter - Security headers
 5. CsrfFilter - CSRF protection
 6. LogoutFilter - Logout handling
 7. UsernamePasswordAuthenticationFilter - Form login
 8. BasicAuthenticationFilter - Basic auth
 9. RequestCacheAwareFilter - Request caching
 10. SecurityContextHolderAwareRequestFilter - Servlet API integration
 11. AnonymousAuthenticationFilter - Anonymous users
 12. SessionManagementFilter - Session fixation protection
 13. ExceptionTranslationFilter - Exception handling
 14. FilterSecurityInterceptor - Authorization decisions
 ================================================================================================================================
 How does Authentication and Authorization work internally?
 Authentication Flow:
 // When credentials arrive
 1. Filter creates UsernamePasswordAuthenticationToken (unauthenticated)
 2. AuthenticationManager.authenticate() called
 3. DaoAuthenticationProvider:
    - Calls UserDetailsService.loadUserByUsername()
    - Compares password using PasswordEncoder
    - Returns authenticated token with authorities
 4. SecurityContextHolder.getContext().setAuthentication()

Authorization Flow:
 When secured resource accessed
1. FilterSecurityInterceptor intercepts
2. Calls AccessDecisionManager
3. AccessDecisionVoters vote (GRANT/DENY/ABSTAIN)
4. If granted, request proceeds
5. If denied, AccessDeniedException thrown
================================================================================================================================
 What is JWT structure and how does each part work?
 JWT has three parts separated by dots: header.payload.signature
1. Header:
   - Specifies token type (JWT) and signing algorithm (e.g., HS256)
   - Example: {"alg":"HS256","typ":"JWT"}
   - Base64Url encoded
2.  Payload:
   {
     "sub": "user123",           // Subject (user ID)
     "iat": 1516239022,          // Issued at
     "exp": 1516242622,          // Expiration
     "iss": "myapp.com",         // Issuer
     "roles": ["USER", "ADMIN"]  // Custom claims
   }
3. Signature:
   - Created by signing the header and payload with a secret key
   - Ensures token integrity and authenticity
   - HMACSHA256(
       base64UrlEncode(header) + "." + base64UrlEncode(payload),
       secret
     )

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain)
            throws ServletException, IOException {

        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(jwtAuthenticationEntryPoint))
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthenticationFilter,
                           UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
================================================================================================================================
How to handle JWT token expiration and blacklisting?
@Service
public class TokenBlacklistService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Autowired
    private JwtTokenProvider tokenProvider;

    public void blacklistToken(String token) {
        Date expiration = tokenProvider.getExpirationFromToken(token);
        long timeToLive = expiration.getTime() - System.currentTimeMillis();

        if (timeToLive > 0) {
            redisTemplate.opsForValue().set(
                "blacklist:" + token,
                "blacklisted",
                timeToLive,
                TimeUnit.MILLISECONDS
            );
        }
    }

    public boolean isBlacklisted(String token) {
        return redisTemplate.hasKey("blacklist:" + token);
    }
}
================================================================================================================================
How does JWT work with LDAP authentication? Explain complete flow
1. User Login Request:
   - User submits credentials (username/password) to the application.
2. LDAP Authentication:
   - Application uses Spring Security's LDAP authentication provider to validate credentials against the LDAP server.
   - If valid, LDAP server returns user details (DN, attributes).
3. JWT Generation:
   - Application generates a JWT containing user information and roles.
   - Signs the JWT with a secret key.
4. Token Delivery:
   - JWT is sent back to the client in the response.
5. Subsequent Requests:
   - Client includes JWT in the Authorization header for future requests.
6. JWT Validation:
   - Application intercepts requests, extracts JWT, and validates signature and expiration.
   - If valid, retrieves user details from JWT.
7. Authorization:
   - Application checks user roles/permissions from JWT for access control.

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated())
            .ldapAuthentication(ldap -> ldap
                .userDnPatterns("uid={0},ou=people")
                .groupSearchBase("ou=groups")
                .contextSource(context -> context
                    .url("ldap://localhost:8389/dc=springframework,dc=org")
                    .managerDn("uid=admin,ou=system")
                    .managerPassword("secret"))
                .passwordCompare(compare -> compare
                    .passwordEncoder(new LdapShaPasswordEncoder())
                    .passwordAttribute("userPassword")))
            .addFilterBefore(jwtAuthenticationFilter(),
                           UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }
}
