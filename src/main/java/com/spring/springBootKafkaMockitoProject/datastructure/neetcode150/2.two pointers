valid palindrome
// Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
// Input:'Was it a car or a cat I saw?'
// Output: true
// Brute force Approach:
// 1. Convert the string to lowercase and remove non-alphanumeric characters.
// 2. Compare the cleaned string with its reverse.
// Time Complexity: O(n) for cleaning and reversing the string.
// Space Complexity: O(n) for the cleaned string.
public class ValidPalindrome {
    public boolean isPalindrome(String s) {
        StringBuilder cleaned = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                cleaned.append(Character.toLowerCase(c));
            }
        }
        String cleanedStr = cleaned.toString();
        String reversedStr = cleaned.reverse().toString();
        return cleanedStr.equals(reversedStr);
    }
}
// Optimized Approach:two-pointer technique
// 1. Use two pointers, one at the start and one at the end of the string.
// 2. Move the pointers towards the center, skipping non-alphanumeric characters.
// 3. Compare the characters at the two pointers, ignoring case.
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            // Skip non-alphanumeric characters from left
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            // Skip non-alphanumeric characters from right
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
=======================================
Two Integer Sum II sorted array
// Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order,
find two numbers such that they add up to a specific target number.
// Return the indices of the two numbers,
// return the answer in any order.
// Input: numbers = [2,7,11,15], target = 9
// Output: [1,2]
// Explanation: The sum of 2 and 7 is 9. Therefore, indices
// 1 and 2 are returned.


class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i=0;
        int j=nums.length-1;
        while(i<j){
            if(nums[i]+nums[j]<target){
            i++;
            }else if(nums[i]+nums[j]>target){
            j--;
            }else{
            return new int[]{i+1,j+1};
            }
        }
        return null;
    }
}
===================================================
3 sum problem
// Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]]
// such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
// Notice that the solution set must not contain duplicate triplets.
// Input: nums = [-1,0,1,2,-1,-4]
// Output: [[-1,-1,2],[-1,0,1]]
// Explanation: The triplets are:
// -1 + 0 + 1 = 0
// -1 + -1 + 2 = 0
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        HashSet<List<Integer>> hashset = new HashSet<>();

        for(int i=0;i<nums.length-2;i++){
            int left =i+1;
            int right=nums.length-1;
            while(left<right){
                if(nums[left]+nums[right]+nums[i]<0){
                    left++;
                }
                else if(nums[left]+nums[right]+nums[i]>0){
                    right--;
                }else{
                   hashset.add(Arrays.asList(nums[left],nums[right],nums[i]));
                   left++;
                   right--;
                }
            }
        }
        return new ArrayList<>(hashset);
    }
}

note->
 nums.length - 2 ensures there are at least two more elements after i
// to form a triplet, preventing out-of-bounds access.
===========================================================================
container with most water
// Given n non-negative integers a1, a2, ..., an, where each represents a
// point at coordinate (i, ai). n vertical lines are drawn such that the
// two endpoints of line i is at (i, ai) and (i, 0
// Find two lines, which together with the x-axis forms a container,
// such that the container contains the most water.
// Input: height = [1,8,6,2,5,4,8,3,7]
// Output: 49
// Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].
// In this case, the max area of water (between the lines i=1 and i=8) is 49.
// The width of the container is 8 - 1 = 7, and the height is min(8,
// 1) = 1. Thus, the area is 7 * 1 = 49.

Brute force Approach:
class Solution {
    public int maxArea(int[] height) {
        int maxArea = 0;

        for (int i = 0; i < height.length; i++) {
            for (int j = i + 1; j < height.length; j++) {
                int h = Math.min(height[i], height[j]);
                int w = j - i;
                int area = h * w;
                maxArea = Math.max(maxArea, area);
            }
        }

        return maxArea;
    }
}

two-pointer Approach:
class Solution {
    public int maxArea(int[] height) {
        int maxArea = 0;
        int left=0;
        int right= height.length-1;

        while(left<right){
         if(height[left]>height[right]){
            maxArea=Math.max(maxArea,height[right]*(right-left));
            right--;
         }else{
            maxArea=Math.max(maxArea,height[left]*(right-left));
            left++;
         }


        }
        return maxArea;
    }
}
============================================================
Trapping Rain Water
// Given n non-negative integers representing an elevation map where the width of each bar is 1
// compute how much water it can trap after raining.
// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
// Output: 6

class Solution {
    public int trap(int[] a) {
        //define two pointer
        int left =0;
        int right =a.length-1;
        int leftMax=0;
        int rightMax=0;
        int tw=0;

        while(left<right){
            if(a[left]<=a[right]){
                if(a[left]>=leftMax){
                    leftMax=a[left];
                }else{
                    tw +=leftMax-a[left];
                }

                left++;
            }else{
                if(a[right]>rightMax){
                    rightMax=a[right];
                }else{
                    tw +=rightMax-a[right];
                }

                right--;
            }

        }
        return tw;
    }
}

note-> first calculate the left max and right max
then calculate the trapped water by subtracting the current height from the left max or right max
==========================================================================

