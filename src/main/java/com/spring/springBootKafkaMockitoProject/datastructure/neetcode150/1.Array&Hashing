Contains Duplicate
Given an integer array nums, return true if any value appears more than once in the array, otherwise return false
Input: nums = [1, 2, 3, 3]
Output: true

class Solution {
    public boolean hasDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();

        for(int i=0;i<nums.length;i++){
            if(set.contains(nums[i])){
                return true;
            }
            set.add(nums[i]);
        }
        return false;
    }
}
========================================================================================
Valid Anagram

Given two strings s and t, return true if the two strings are anagrams of each other,
otherwise return false.
Input: s = "racecar", t = "carrace"
Output: true

class Solution {
    public boolean isAnagram(String s, String t) {
      char [] s1=  s.toCharArray();
      char [] t1=  t.toCharArray();
      Arrays.sort(s1);
      Arrays.sort(t1);
      if(s1.length!=t1.length){
        return false;
      }
      for(int i=0;i<s1.length;i++){
        if(s1[i]!=t1[i]){
            return false;
        }
      }
    return true;
    }
}
==========================================================================================
Two Sum

Given an array of integers nums and an integer target,
return the indices i and j such that nums[i] + nums[j] == target and i != j.

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> numMap = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int diff = target - nums[i];
            if(numMap.containsKey(diff)){
                return new int[]{numMap.get(diff),i};
            }else{
                numMap.put(nums[i],i);
        }
    }
    return new int []{};
}
}
==============================================================================================


========================================================================================
Top K Frequent Elements

Input: nums = [1,2,2,3,3,3], k = 2
Output: [2,3]

Brute force Approach:
// 1. Create a frequency map to count occurrences of each number.
// 2. Sort the map by frequency and return the top k elements.
// Time Complexity: O(n log n) due to sorting.
// Space Complexity: O(n) for the frequency map.


public class TopKFrequentElements {
    public List<Integer> topKFrequent(int[] nums, int k) {
        // Step 1: Create a frequency map
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // Step 2: Sort the map by frequency and get the top k elements
        List<Map.Entry<Integer, Integer>> entryList = new ArrayList<>(frequencyMap.entrySet());
        entryList.sort((a, b) -> b.getValue().compareTo(a.getValue()));

        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            result.add(entryList.get(i).getKey());
        }
        return result;
    }
}

optimization Approach:bucket sort
// 1. Create a frequency map to count occurrences of each number.
// 2. Create a bucket array where the index represents frequency.
// 3. Iterate through the frequency map and place each number in the corresponding bucket.
// 4. Collect the top k elements from the buckets.

class Solution {
    public int[] topKFrequent(int[] nums, int k) {

        List<Integer>[] bucket = new List[nums.length+1];

        if(nums.length==1){
            return nums;
        }
        Map<Integer,Integer> frequencyMap = new HashMap<>();
        for(int n : nums){
           frequencyMap.put(n,frequencyMap.getOrDefault(n,0)+1);
        }

        for(Integer key  :frequencyMap.keySet()){

            int freq = frequencyMap.get(key);

            if(bucket[freq]==null){
               bucket[freq]= new ArrayList<>();
            }
            bucket[freq].add(key);
        }

        int [] result = new int[k];
        int counter=0;
        for(int i =bucket.length-1;i>=0 && counter<k; i--){
            if(bucket[i]!=null){
                for(Integer num : bucket[i]){
                    result[counter++]=num;
                }
            }
        }

        return result;

}
}
=========================================================================
Products of Array Except Self
// Given an integer array nums, return an array answer such that answer[i]
is equal to the product of all the elements of nums except nums[i].

Input: nums = [1,2,4,6]
Output: [48,24,12,8]

// Brute force Approach:
// 1. Create an output array of the same length as nums.
// 2. For each index i, calculate the product of all elements except nums[i]
//    by iterating through the nums array.
// Time Complexity: O(n^2) due to nested loops.
public class ProductOfArrayExceptSelf {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] output = new int[n];

        for (int i = 0; i < n; i++) {
            output[i] = 1;
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    output[i] *= nums[j];
                }
            }
        }
        return output;
    }
}

// Optimized Approach:
// 1. Create two arrays, left and right, to store the product of elements
//    to the left and right of each index.
// 2. Iterate through the nums array to fill the left array.
// 3. Iterate through the nums array in reverse to fill the right array.
// 4. Multiply the corresponding elements of left and right to get the output.
class Solution {
    public int[] productExceptSelf(int[] nums) {

        int[] left = new int[nums.length];
        int[] right = new int[nums.length];
        int[] output = new int[nums.length];

        left[0] =1;
        for(int i=1;i<nums.length;i++){
            left[i]=left[i-1]*nums[i-1];
        }

        right[nums.length-1] =1;

        for(int i=nums.length-2;i>-1;i--){
            right[i]=right[i+1]*nums[i+1];
        }

        for(int i=0;i<nums.length;i++){
            output[i]=left[i]*right[i];
        }
        return output;
    }
}
note->divisable approach will fail beacuse of zero elements in the array.
=============================
// Longest Consecutive Sequence
// Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence
// Input: nums = [100,4,200,1,3,2]
// Output: 4
HashSet Approach:
// 1. Create a HashSet to store the elements of the array.
// 2. Iterate through each element in the array.
// 3. For each element, check if it is the start of a consecutive sequence.
// 4. If it is, count the length of the sequence by checking for consecutive elements
//    in the HashSet.
// Time Complexity: O(n) for inserting elements into the HashSet and O(n) for checking consecutive elements.
// Space Complexity: O(n) for the HashSet.
public class LongestConsecutiveSequence {
    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        int longestStreak = 0;
        for (int num : nums) {
        //if 4 is first and 3 is later in array then Because if 4 is part of a sequence starting at 3, weâ€™ll already count it when we check 3.
        //hence we currently ignoring 4
            if (!numSet.contains(num - 1)) { // Check if num is the start of a sequence
                int currentNum = num;
                int currentStreak = 1;
                while (numSet.contains(currentNum + 1)) { // Count consecutive elements
                    currentNum++;
                    currentStreak++;
                }
                longestStreak = Math.max(longestStreak, currentStreak); // Update longest
            }
        }
        return longestStreak;
    }
}
===============================================
